from pandas import DataFrame
import pandas as pd
import numpy as np
import requests
import json
import arrow
import os
from bs4 import BeautifulSoup
import urllib


class Item:
    """
    Each TF2 item is represented as a `pandas` `DataFrame` object demarcating its historical cost table.
    """

    name = ""
    quality = ""
    craftability = ""
    tradability = ""
    history = DataFrame()

    def __repr__(self):
        return str(self.history)

    def __init__(self, item, **kwargs):
        """
        Every Item has an associated filename, generated by `str_repr` below. If the associated file is present in
        the folder initialization loads the data from there. If it is not initialization makes an API query,
        loads the results, and stores the file---for future reference.
        """
        self.name = item
        if item == "Mann Co. Supply Crate Key":
            key = _key_prices()
            self.history = key.history
        elif item == "Refined Metal":
            metal = _metal_prices()
            self.history = metal.history
        else:
            str_repr = ""
            if 'quality' not in kwargs.keys():
                str_repr += "unique "
                self.quality = "unique"
            else:
                str_repr += kwargs['quality'].lower() + " "
                self.quality = kwargs['quality'].lower()
            if 'craftable' not in kwargs.keys() or kwargs['craftable'] == 1 or kwargs['craftable'] == 'Craftable':
                str_repr += "craftable "
                self.craftability = "craftable"
            else:
                str_repr += "non-craftable "
                self.craftability = "non-craftable"
            if 'tradable' not in kwargs.keys() or kwargs['tradable'] == 1 or kwargs['tradable'] == 'Tradable':
                str_repr += "tradable "
                self.tradability = "tradable"
            elif kwargs['tradable'] == 0:
                str_repr += "non-tradable "
                self.tradability = "non-tradable"
            if "{0}{1}.csv".format(str_repr, item.lower()) in [f for f in os.listdir('.') if os.path.isfile(f)]:
                self.read_csv("{0}{1}.csv".format(str_repr, item.lower()))
            else:
                if len(item) > 0:
                    # Make the API call.
                    params = {"key": _get_key(), "item": item}
                    params.update(kwargs)
                    data = json.loads(requests.get("http://backpack.tf/api/IGetPriceHistory/v1/",
                                                   params=params).text)['response']['history']
                    # Parse it into a `pandas` `DataFrame`.
                    frame = DataFrame(data,
                                      index=[np.datetime64(str(arrow.get(t['timestamp']).format('YYYY-MM-DD'))) for t in
                                             data],
                                      columns=["currency", "value", "value_high"])
                    # Throw out earlier dates, for the moment. `2013-01-01` is the starting point for all knowledge.
                    frame = frame[pd.to_datetime('2013-01-01'):]
                    # Convert currency.
                    metal = _metal_prices()
                    key = _key_prices()
                    # Throw out "hat" currencied values. Weird stopgap that they used briefly (hopefully).
                    frame = frame[frame['currency'] != 'hat']
                    for i in range(0, len(frame.index)):
                        data = frame.iloc[i]
                        date = data.name
                        currency = data['currency']
                        conversion_rate = _value_at(currency, date, key, metal)
                        frame.iat[i, 0] = 'usd'
                        # FAILURE POINT: Item instantiation fails here.
                        # print(conversion_rate[0])
                        # print(frame.iat[i, 1])
                        frame.iat[i, 1] *= conversion_rate[0]
                        frame.iat[i, 2] *= conversion_rate[1]
                    self.history = frame
                    # self.to_csv("{0}{1}.csv".format(str_repr, item.lower()))

    def to_csv(self, filename):
        """
        Pass-through wrapper that saves the `Item` in CSV.
        :param filename: The filename at which to save the `Item`.
        """
        self.history.to_csv(filename)

    def read_csv(self, filename):
        """
        Pass-through wrapper that loads the `Item` in CSV.
        :param filename: The filename from which to load the `Item`.
        """
        self.history = self.history.from_csv(filename)


def _value_at(currency, date, key, metal):
    """
    Converts one currency into USD based on a date. To speed up the operation key and metal are passed to this
    internal method so that the required table lookups only need happen once.
    :param currency: String representing the currency being converted into USD, one of ["usd", "metal", "keys",
    or "hat"]. That last one...I just throw hat out in the in-definition smoothing step.
    :param date: The date of the conversion.
    :param key: A key `DataFrame` history object.
    :param metal: A metal `DataFrame` history object.
    :return: The value of the given currency at the given date in USD.
    """
    f_date = np.datetime64(str(arrow.get(date).format('YYYY-MM-DD')))
    # USD-to-USD conversion is a multiple of 1.
    if currency == "usd":
        return 1, 1
    # Convert metal prices based on historical data.
    elif currency == "metal":
        value_entry = metal.history[:f_date].tail(1)
        return value_entry['value'][0], value_entry['value_high'][0]
    # Convert key prices based on historical data.
    elif currency == "keys":
        value_entry = key.history[:f_date].tail(1)
        return value_entry['value'][0], value_entry['value_high'][0]


def _get_key(filename='backpack_tf_account_credentials.json'):
    if filename in [f for f in os.listdir('.') if os.path.isfile(f)]:
        return json.load(open(filename))['credentials']['token']
    else:
        raise IOError(
                'This API requires a backpack.tf credentials token to work. Did you forget to generate one? For more '
                'information refer to:\n\nhttps://backpack.tf/api/pricehistory')


def _metal_prices(filename='unique craftable tradable refined metal.csv'):
    """
    Retrieves the metal price table. Since this operation is needed whenever a conversion is made the data is saved
    locally as a CSV and extracted from there.
    :param filename: The filename at which metal prices are saved.
    :return: The `DataFrame` price history object.
    """
    if filename in [f for f in os.listdir('.') if os.path.isfile(f)]:
        ret = Item("")
        ret.read_csv(filename)
        return ret
    else:
        params = {"key": _get_key(), "item": "Refined Metal"}
        data = json.loads(requests.get("http://backpack.tf/api/IGetPriceHistory/v1/",
                                       params=params).text)['response']['history']
        # Parse it into a `pandas` `DataFrame`.
        frame = DataFrame(data,
                          index=[np.datetime64(str(arrow.get(t['timestamp']).format('YYYY-MM-DD'))) for t in
                                 data],
                          columns=["currency", "value", "value_high"])
        # Extrapolate Refined Metal price back to `2013-01-01`.
        frame.loc[pd.to_datetime('2013-01-01')] = ['usd', 0.40, 0.40]
        frame = frame.sort_index()
        metal = Item("")
        metal.history = frame
        metal.craftability = "craftable"
        metal.tradability = "tradable"
        metal.to_csv(filename)
        return metal


def _key_prices(filename='unique craftable tradable mann co. supply crate key.csv'):
    """
    Retrieves the key price table.
    :param filename: The filename at which key prices are saved.
    :return: The `DataFrame` price history object.
    """
    if filename in [f for f in os.listdir('.') if os.path.isfile(f)]:
        ret = Item("")
        ret.read_csv(filename)
        return ret
    else:
        params = {"key": _get_key(), "item": "Mann Co. Supply Crate Key"}
        data = json.loads(requests.get("http://backpack.tf/api/IGetPriceHistory/v1/",
                                       params=params).text)['response']['history']
        # Parse it into a `pandas` `DataFrame`.
        frame = DataFrame(data,
                          index=[np.datetime64(str(arrow.get(t['timestamp']).format('YYYY-MM-DD'))) for t in
                                 data],
                          columns=["currency", "value", "value_high"])
        frame = frame[pd.to_datetime('2013-01-01'):]
        metal = _metal_prices()
        for i in range(0, len(frame.index)):
            data = frame.iloc[i]
            date = data.name
            frame = frame[pd.to_datetime('2013-01-01'):]
            currency = data['currency']
            conversion_rate = _value_at(currency, date, None, metal)
            frame.iat[i, 0] = 'usd'
            frame.iat[i, 1] *= conversion_rate[0]
            frame.iat[i, 2] *= conversion_rate[1]
        key = Item("")
        key.history = frame
        key.craftability = "craftable"
        key.tradability = "tradable"
        key.to_csv(filename=filename)
        return key


def get_all_items():
    """
    Returns a list of all non-unusual items in the game.
    :return:
    """
    spreadsheet = BeautifulSoup(requests.get("http://backpack.tf/pricelist/spreadsheet").text, 'html.parser')
    item_strings = spreadsheet.find_all("a", {"class": 'qlink'})
    # return item_strings
    # return [urllib.request.unquote(str(item_string)).split("/")[3] for item_string in item_strings]
    ret = []
    for item_string in item_strings:
        item_string = str(item_string)
        string_repr = "{0} {1} {2} {3}".format(item_string.split("/")[2],
                                               item_string.split("/")[4],
                                               item_string.split("/")[5][:item_string.split("/")[5].find('"')],
                                               urllib.request.unquote(item_string.split("/")[3]))
        # string_repr = urllib.request.unquote(str(item_string).split("/")[3])
        ret.append(string_repr)
    return ret